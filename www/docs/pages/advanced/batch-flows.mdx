# Batch Flows

Process multiple parameter sets through flows using BatchNode, perfect for handling multiple entities or parallel workflows.

## Basic Batch Flow

Use BatchNode to process multiple parameter sets:

```go
// Create a batch node that processes multiple user parameters
batchNode := flyt.NewBatchNode().
    WithPrepFunc(func(ctx context.Context, shared *flyt.SharedStore) ([]flyt.Result, error) {
        // Prepare multiple parameter sets
        return []flyt.Result{
            flyt.NewResult(map[string]any{"user_id": 1, "email": "user1@example.com"}),
            flyt.NewResult(map[string]any{"user_id": 2, "email": "user2@example.com"}),
            flyt.NewResult(map[string]any{"user_id": 3, "email": "user3@example.com"}),
        }, nil
    }).
    WithExecFunc(func(ctx context.Context, params flyt.Result) (flyt.Result, error) {
        // Process each parameter set
        data := params.MustMap()
        userID := data["user_id"].(int)
        email := data["email"].(string)
        
        // Run your processing logic
        result := processUser(userID, email)
        return flyt.NewResult(result), nil
    }).
    WithPostFunc(func(ctx context.Context, shared *flyt.SharedStore, params, results []flyt.Result) (flyt.Action, error) {
        // Aggregate results from all parameter sets
        var allResults []any
        var errors []error
        
        for i, r := range results {
            if r.IsError() {
                log.Printf("Failed to process user %v: %v", params[i].Value(), r.Error())
                errors = append(errors, r.Error())
            } else {
                allResults = append(allResults, r.Value())
            }
        }
        
        shared.Set("all_results", allResults)
        shared.Set("error_count", len(errors))
        
        if len(errors) > 0 {
            return "partial_success", nil
        }
        return flyt.DefaultAction, nil
    })

// Create a flow starting with the batch node
flow := flyt.NewFlow(batchNode)
flow.Connect(batchNode, flyt.DefaultAction, aggregateNode)
flow.Connect(batchNode, "partial_success", errorHandlerNode)

// Run the flow
shared := flyt.NewSharedStore()
err := flow.Run(ctx, shared)
```

## Sequential vs Concurrent Execution

Control how parameter sets are processed:

```go
// Sequential - process one at a time, maintains order
sequentialBatch := flyt.NewBatchNode().
    WithPrepFunc(prepFunc).
    WithExecFunc(execFunc).
    WithPostFunc(postFunc).
    WithBatchConcurrency(0)  // 0 = sequential

// Concurrent - process multiple in parallel
concurrentBatch := flyt.NewBatchNode().
    WithPrepFunc(prepFunc).
    WithExecFunc(execFunc).
    WithPostFunc(postFunc).
    WithBatchConcurrency(10)  // Process up to 10 concurrently
```

## Dynamic Input Generation

Generate inputs based on runtime data:

```go
batchNode := flyt.NewBatchNode().
    WithPrepFunc(func(ctx context.Context, shared *flyt.SharedStore) ([]flyt.Result, error) {
        // Get configuration from shared store
        config := shared.GetMap("batch_config")
        batchSize := config["size"].(int)
        
        // Fetch data from database
        users, err := fetchUsers(batchSize)
        if err != nil {
            return nil, fmt.Errorf("failed to fetch users: %w", err)
        }
        
        // Convert to Results
        results := make([]flyt.Result, len(users))
        for i, user := range users {
            results[i] = flyt.NewResult(map[string]any{
                "user_id":   user.ID,
                "user_name": user.Name,
                "user_data": user,
            })
        }
        
        return results, nil
    }).
    WithExecFunc(func(ctx context.Context, userResult flyt.Result) (flyt.Result, error) {
        userData := userResult.MustMap()
        user := userData["user_data"].(User)
        
        // Process individual user
        processed, err := processUserData(user)
        if err != nil {
            return flyt.Result{}, fmt.Errorf("failed to process user %d: %w", user.ID, err)
        }
        
        return flyt.NewResult(processed), nil
    }).
    WithPostFunc(func(ctx context.Context, shared *flyt.SharedStore, users, results []flyt.Result) (flyt.Action, error) {
        successCount := 0
        for _, result := range results {
            if !result.IsError() {
                successCount++
            }
        }
        
        log.Printf("Processed %d/%d users successfully", successCount, len(users))
        shared.Set("success_rate", float64(successCount)/float64(len(users)))
        
        return flyt.DefaultAction, nil
    })
```

## Complex Processing Pipeline

Create sophisticated processing for each batch item:

```go
// Create a batch node that runs a multi-step pipeline for each item
pipelineBatchNode := flyt.NewBatchNode().
    WithPrepFunc(func(ctx context.Context, shared *flyt.SharedStore) ([]flyt.Result, error) {
        orders := shared.GetSlice("orders")
        results := make([]flyt.Result, len(orders))
        for i, order := range orders {
            results[i] = flyt.NewResult(order)
        }
        return results, nil
    }).
    WithExecFunc(func(ctx context.Context, orderResult flyt.Result) (flyt.Result, error) {
        var order Order
        if err := orderResult.Bind(&order); err != nil {
            return flyt.Result{}, err
        }
        
        // Multi-step processing pipeline
        // Step 1: Validate
        if err := validateOrder(order); err != nil {
            return flyt.Result{}, fmt.Errorf("validation failed: %w", err)
        }
        
        // Step 2: Enrich
        enrichedOrder, err := enrichOrderData(order)
        if err != nil {
            return flyt.Result{}, fmt.Errorf("enrichment failed: %w", err)
        }
        
        // Step 3: Process
        processedOrder, err := processOrder(enrichedOrder)
        if err != nil {
            return flyt.Result{}, fmt.Errorf("processing failed: %w", err)
        }
        
        // Step 4: Save
        if err := saveOrder(processedOrder); err != nil {
            return flyt.Result{}, fmt.Errorf("save failed: %w", err)
        }
        
        return flyt.NewResult(processedOrder), nil
    }).
    WithPostFunc(func(ctx context.Context, shared *flyt.SharedStore, orders, results []flyt.Result) (flyt.Action, error) {
        var processed []Order
        var failed []map[string]any
        
        for i, result := range results {
            if result.IsError() {
                original := orders[i].Value()
                failed = append(failed, map[string]any{
                    "order": original,
                    "error": result.Error().Error(),
                })
            } else {
                var order Order
                result.Bind(&order)
                processed = append(processed, order)
            }
        }
        
        shared.Set("processed_orders", processed)
        shared.Set("failed_orders", failed)
        
        if len(failed) > 0 {
            return "has_failures", nil
        }
        return "all_success", nil
    }).
    WithBatchConcurrency(5).
    WithBatchErrorHandling(true)  // Continue processing despite failures
```

## Batch with Configuration

Pass configuration to batch processing:

```go
func createConfiguredBatchNode(config ProcessConfig) *flyt.BatchNodeBuilder {
    return flyt.NewBatchNode().
        WithPrepFunc(func(ctx context.Context, shared *flyt.SharedStore) ([]flyt.Result, error) {
            // Use config to determine what to process
            var items []flyt.Result
            
            switch config.Source {
            case "database":
                data, err := fetchFromDB(config.DBConfig)
                if err != nil {
                    return nil, err
                }
                for _, item := range data {
                    items = append(items, flyt.NewResult(item))
                }
            case "api":
                data, err := fetchFromAPI(config.APIConfig)
                if err != nil {
                    return nil, err
                }
                for _, item := range data {
                    items = append(items, flyt.NewResult(item))
                }
            default:
                return nil, fmt.Errorf("unknown source: %s", config.Source)
            }
            
            return items, nil
        }).
        WithExecFunc(func(ctx context.Context, item flyt.Result) (flyt.Result, error) {
            // Apply configuration to processing
            if config.ValidateEnabled {
                if err := validate(item.Value()); err != nil {
                    return flyt.Result{}, err
                }
            }
            
            result := process(item.Value(), config.ProcessOptions)
            
            if config.TransformEnabled {
                result = transform(result, config.TransformOptions)
            }
            
            return flyt.NewResult(result), nil
        }).
        WithPostFunc(func(ctx context.Context, shared *flyt.SharedStore, items, results []flyt.Result) (flyt.Action, error) {
            // Save based on configuration
            var successful []any
            for _, result := range results {
                if !result.IsError() {
                    successful = append(successful, result.Value())
                }
            }
            
            if config.SaveEnabled {
                if err := saveResults(successful, config.SaveOptions); err != nil {
                    return "", fmt.Errorf("save failed: %w", err)
                }
            }
            
            shared.Set("results", successful)
            return flyt.DefaultAction, nil
        }).
        WithBatchConcurrency(config.Concurrency).
        WithMaxRetries(config.MaxRetries)
}
```

## Result Aggregation

Collect and aggregate results from batch processing:

```go
aggregatingBatchNode := flyt.NewBatchNode().
    WithPrepFunc(func(ctx context.Context, shared *flyt.SharedStore) ([]flyt.Result, error) {
        metrics := shared.GetSlice("metrics")
        results := make([]flyt.Result, len(metrics))
        for i, metric := range metrics {
            results[i] = flyt.NewResult(metric)
        }
        return results, nil
    }).
    WithExecFunc(func(ctx context.Context, metric flyt.Result) (flyt.Result, error) {
        var m Metric
        if err := metric.Bind(&m); err != nil {
            return flyt.Result{}, err
        }
        
        // Calculate metric value
        value, err := calculateMetric(m)
        if err != nil {
            return flyt.Result{}, err
        }
        
        return flyt.NewResult(map[string]any{
            "name":  m.Name,
            "value": value,
            "timestamp": time.Now(),
        }), nil
    }).
    WithPostFunc(func(ctx context.Context, shared *flyt.SharedStore, metrics, results []flyt.Result) (flyt.Action, error) {
        // Aggregate all metric results
        aggregated := map[string]any{
            "timestamp": time.Now(),
            "metrics":   []map[string]any{},
            "summary":   map[string]any{},
        }
        
        var total float64
        var count int
        var min, max float64
        
        for _, result := range results {
            if !result.IsError() {
                metricData := result.MustMap()
                aggregated["metrics"] = append(
                    aggregated["metrics"].([]map[string]any),
                    metricData,
                )
                
                value := metricData["value"].(float64)
                total += value
                count++
                
                if count == 1 || value < min {
                    min = value
                }
                if value > max {
                    max = value
                }
            }
        }
        
        if count > 0 {
            aggregated["summary"] = map[string]any{
                "count":   count,
                "total":   total,
                "average": total / float64(count),
                "min":     min,
                "max":     max,
            }
        }
        
        shared.Set("aggregated_metrics", aggregated)
        return flyt.DefaultAction, nil
    })
```

## Progress Tracking

Track progress across batch execution:

```go
progressBatchNode := flyt.NewBatchNode().
    WithPrepFunc(func(ctx context.Context, shared *flyt.SharedStore) ([]flyt.Result, error) {
        tasks := shared.GetSlice("tasks")
        results := make([]flyt.Result, len(tasks))
        
        log.Printf("Starting batch processing of %d tasks", len(tasks))
        shared.Set("total_tasks", len(tasks))
        shared.Set("start_time", time.Now())
        
        for i, task := range tasks {
            results[i] = flyt.NewResult(task)
        }
        return results, nil
    }).
    WithExecFunc(func(ctx context.Context, task flyt.Result) (flyt.Result, error) {
        // Process task
        result, err := processTask(task.Value())
        if err != nil {
            return flyt.Result{}, err
        }
        return flyt.NewResult(result), nil
    }).
    WithPostFunc(func(ctx context.Context, shared *flyt.SharedStore, tasks, results []flyt.Result) (flyt.Action, error) {
        startTime := shared.Get("start_time").(time.Time)
        duration := time.Since(startTime)
        
        successful := 0
        failed := 0
        
        for _, result := range results {
            if result.IsError() {
                failed++
            } else {
                successful++
            }
        }
        
        log.Printf("Batch completed in %v: %d successful, %d failed out of %d total",
                   duration, successful, failed, len(tasks))
        
        shared.Set("batch_stats", map[string]any{
            "total":      len(tasks),
            "successful": successful,
            "failed":     failed,
            "duration":   duration.Seconds(),
            "rate":       float64(len(tasks)) / duration.Seconds(),
        })
        
        return flyt.DefaultAction, nil
    }).
    WithBatchConcurrency(10)
```

## Conditional Batch Processing

Process batches based on conditions:

```go
conditionalBatchNode := flyt.NewBatchNode().
    WithPrepFunc(func(ctx context.Context, shared *flyt.SharedStore) ([]flyt.Result, error) {
        allItems := shared.GetSlice("items")
        processingMode := shared.GetString("mode")
        
        var itemsToProcess []flyt.Result
        
        for _, item := range allItems {
            itemMap := item.(map[string]any)
            
            // Apply conditional logic
            shouldProcess := false
            switch processingMode {
            case "priority":
                shouldProcess = itemMap["priority"].(string) == "high"
            case "recent":
                timestamp := itemMap["timestamp"].(time.Time)
                shouldProcess = time.Since(timestamp) < 24*time.Hour
            case "pending":
                shouldProcess = itemMap["status"].(string) == "pending"
            default:
                shouldProcess = true
            }
            
            if shouldProcess {
                itemsToProcess = append(itemsToProcess, flyt.NewResult(item))
            }
        }
        
        log.Printf("Processing %d out of %d items based on %s mode",
                   len(itemsToProcess), len(allItems), processingMode)
        
        return itemsToProcess, nil
    }).
    WithExecFunc(func(ctx context.Context, item flyt.Result) (flyt.Result, error) {
        // Process selected item
        processed, err := processItem(item.Value())
        if err != nil {
            return flyt.Result{}, err
        }
        return flyt.NewResult(processed), nil
    }).
    WithPostFunc(func(ctx context.Context, shared *flyt.SharedStore, items, results []flyt.Result) (flyt.Action, error) {
        var processed []any
        for _, result := range results {
            if !result.IsError() {
                processed = append(processed, result.Value())
            }
        }
        
        shared.Set("processed_items", processed)
        return flyt.DefaultAction, nil
    })
```

## Error Recovery

Handle and recover from batch failures:

```go
recoverableBatchNode := flyt.NewBatchNode().
    WithPrepFunc(func(ctx context.Context, shared *flyt.SharedStore) ([]flyt.Result, error) {
        items := shared.GetSlice("items")
        results := make([]flyt.Result, len(items))
        for i, item := range items {
            results[i] = flyt.NewResult(item)
        }
        return results, nil
    }).
    WithExecFunc(func(ctx context.Context, item flyt.Result) (flyt.Result, error) {
        // Try processing
        result, err := riskyOperation(item.Value())
        if err != nil {
            // Try recovery
            if recoverable, ok := err.(RecoverableError); ok {
                log.Printf("Attempting recovery for: %v", recoverable)
                result, err = recoverOperation(item.Value(), recoverable)
                if err != nil {
                    return flyt.Result{}, fmt.Errorf("recovery failed: %w", err)
                }
                return flyt.NewResult(map[string]any{
                    "result":    result,
                    "recovered": true,
                })
            }
            return flyt.Result{}, err
        }
        
        return flyt.NewResult(map[string]any{
            "result":    result,
            "recovered": false,
        })
    }).
    WithPostFunc(func(ctx context.Context, shared *flyt.SharedStore, items, results []flyt.Result) (flyt.Action, error) {
        var successful []any
        var recovered []any
        var failed []any
        
        for i, result := range results {
            if result.IsError() {
                failed = append(failed, items[i].Value())
            } else {
                data := result.MustMap()
                if data["recovered"].(bool) {
                    recovered = append(recovered, data["result"])
                } else {
                    successful = append(successful, data["result"])
                }
            }
        }
        
        shared.Set("successful", successful)
        shared.Set("recovered", recovered)
        shared.Set("failed", failed)
        
        log.Printf("Results: %d successful, %d recovered, %d failed",
                   len(successful), len(recovered), len(failed))
        
        if len(failed) > 0 {
            return "has_failures", nil
        }
        return flyt.DefaultAction, nil
    }).
    WithBatchErrorHandling(true).  // Continue despite failures
    WithMaxRetries(3)              // Retry failed items
```

## Best Practices

1. **Use Results Properly**: Always check `Result.IsError()` before accessing values
2. **Log Progress**: Add logging in Post to track batch completion
3. **Handle Failures**: Decide whether one failure should affect others
4. **Track Progress**: Implement progress tracking for long-running batches
5. **Configure Concurrency**: Set appropriate concurrency based on resource constraints
6. **Clean Error Handling**: Use Result error tracking for clean error propagation

## Next Steps

- [Batch Processing](/advanced/batch-processing) - Core batch processing concepts
- [Error Handling](/patterns/error-handling) - Handle errors effectively
- [Worker Pool](/advanced/worker-pool) - Custom concurrent processing