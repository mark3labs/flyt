# Shared Store

The SharedStore provides thread-safe data sharing between nodes in a flow. It acts as a key-value store that persists throughout flow execution with type-safe helpers for common operations.

## Creating a SharedStore

```go
shared := flyt.NewSharedStore()
```

## Basic Operations

### Set and Get

Store and retrieve individual values with the original API:

```go
// Set a value
shared.Set("user_id", 123)
shared.Set("config", map[string]any{"timeout": 30})

// Get a value (original method with type assertion)
if value, ok := shared.Get("user_id"); ok {
    userID := value.(int)
    fmt.Printf("User ID: %d\n", userID)
}
```

### Type-Safe Getters

Use type-specific getters to avoid manual type assertions:

```go
// Type-safe getters (return zero values if not found or wrong type)
userID := shared.GetInt("user_id")           // Returns 0 if not found
name := shared.GetString("name")              // Returns "" if not found
price := shared.GetFloat64("price")           // Returns 0.0 if not found
enabled := shared.GetBool("enabled")          // Returns false if not found
items := shared.GetSlice("items")             // Returns nil if not found
config := shared.GetMap("config")             // Returns nil if not found

// Type-safe getters with custom defaults
userID = shared.GetIntOr("user_id", -1)              // Returns -1 if not found
name = shared.GetStringOr("name", "anonymous")       // Returns "anonymous" if not found
price = shared.GetFloat64Or("price", 99.99)          // Returns 99.99 if not found
enabled = shared.GetBoolOr("enabled", true)          // Returns true if not found
```

The type-safe getters handle numeric conversions automatically:
- `GetInt()` converts from int8, int16, int32, int64, uint variants, and float types
- `GetFloat64()` converts from all numeric types including int and float32

### Bind Method

Bind complex types directly to structs (similar to Echo framework):

```go
// Define your struct
type User struct {
    ID       int      `json:"id"`
    Name     string   `json:"name"`
    Email    string   `json:"email"`
    Tags     []string `json:"tags"`
}

// Store as map
shared.Set("user", map[string]any{
    "id":    123,
    "name":  "Alice",
    "email": "alice@example.com",
    "tags":  []string{"admin", "developer"},
})

// Bind to struct
var user User
err := shared.Bind("user", &user)  // Automatically converts map to struct
if err != nil {
    // Handle error
}

// Or use MustBind (panics on failure - use for required data)
var config Config
shared.MustBind("config", &config)
```

### Utility Methods

Additional helper methods for store management:

```go
// Check if key exists
if shared.Has("user_id") {
    // Key exists
}

// Delete a key
shared.Delete("temp_data")

// Get all keys
keys := shared.Keys()  // Returns []string

// Get number of items
count := shared.Len()

// Clear all items
shared.Clear()
```

### GetAll

Get a copy of all stored data:

```go
allData := shared.GetAll()
for key, value := range allData {
    fmt.Printf("%s: %v\n", key, value)
}
```

### Merge

Merge multiple values at once:

```go
shared.Merge(map[string]any{
    "status": "active",
    "timestamp": time.Now(),
    "metadata": map[string]string{
        "version": "1.0",
        "env": "production",
    },
})
```

## Thread Safety

SharedStore is safe for concurrent access:

```go
var wg sync.WaitGroup

// Multiple goroutines can safely access
for i := 0; i < 10; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        shared.Set(fmt.Sprintf("worker_%d", id), "done")
    }(i)
}

wg.Wait()
```

## Common Patterns

### Configuration Storage

Store configuration that multiple nodes need:

```go
// Define configuration struct
type APIConfig struct {
    BaseURL string `json:"base_url"`
    APIKey  string `json:"api_key"`
    Timeout string `json:"timeout"`
}

// In main or initial node
shared.Set("api_config", APIConfig{
    BaseURL: "https://api.example.com",
    APIKey:  os.Getenv("API_KEY"),
    Timeout: "30s",
})

// In any node - using Bind
func (n *APINode) Prep(ctx context.Context, shared *flyt.SharedStore) (any, error) {
    var config APIConfig
    if err := shared.Bind("api_config", &config); err != nil {
        return nil, err
    }
    return config, nil
}

// Or using GetMap for simple access
func (n *APINode) Prep(ctx context.Context, shared *flyt.SharedStore) (any, error) {
    config := shared.GetMap("api_config")
    return config, nil
}
```

### Accumulating Results

Collect results from multiple nodes:

```go
// Node 1 - Using type-safe getters
func (n *Node1) Post(ctx context.Context, shared *flyt.SharedStore, prepResult, execResult any) (flyt.Action, error) {
    // GetSlice returns nil if not found, perfect for initialization
    results := shared.GetSlice("results")
    if results == nil {
        results = []any{}
    }
    
    results = append(results, execResult)
    shared.Set("results", results)
    
    return flyt.DefaultAction, nil
}
```

### State Management

Track workflow state with type safety:

```go
// Initialize state
shared.Set("workflow_state", "initialized")
shared.Set("retry_count", 0)
shared.Set("start_time", time.Now())

// Update state in nodes with increment
func incrementRetry(shared *flyt.SharedStore) int {
    count := shared.GetInt("retry_count")
    count++
    shared.Set("retry_count", count)
    shared.Set("last_retry", time.Now())
    return count
}

// Check state
func checkState(shared *flyt.SharedStore) string {
    return shared.GetStringOr("workflow_state", "unknown")
}
```

### Error Context

Store error information for debugging:

```go
func (n *ErrorHandler) Post(ctx context.Context, shared *flyt.SharedStore, prepResult, execResult any) (flyt.Action, error) {
    if err := execResult.(error); err != nil {
        shared.Set("last_error", map[string]any{
            "error": err.Error(),
            "node": "ProcessNode",
            "timestamp": time.Now(),
            "input": prepResult,
        })
        return "error", nil
    }
    return flyt.DefaultAction, nil
}
```

## Batch Processing

SharedStore in batch operations:

```go
// Store items to process
shared.Set("items", []string{"item1", "item2", "item3"})

// Store batch configuration
shared.Set("batch_config", map[string]any{
    "batch_size": 10,
    "concurrent": true,
    "timeout": 60,
})

// After batch processing
results, _ := shared.Get("results")
errors, _ := shared.Get("errors")
```

## Isolation in Batch Flows

Each flow in a batch has its own SharedStore:

```go
batchFunc := func(ctx context.Context, shared *flyt.SharedStore) ([]flyt.FlowInputs, error) {
    // This shared is from the parent
    baseConfig, _ := shared.Get("base_config")
    
    return []flyt.FlowInputs{
        {"id": 1, "config": baseConfig}, // Each gets own SharedStore
        {"id": 2, "config": baseConfig},
    }, nil
}
```

## Best Practices

### 1. Type Safety

Use type-safe getters to avoid manual assertions:

```go
// Old way - manual type assertion
if value, ok := shared.Get("count"); ok {
    if count, ok := value.(int); ok {
        // Use count
    } else {
        // Handle type mismatch
    }
}

// New way - type-safe getter
count := shared.GetInt("count")  // Returns 0 if not found or wrong type

// Or with custom default
count := shared.GetIntOr("count", -1)  // Returns -1 if not found

// For complex types, use Bind
var userData UserData
if err := shared.Bind("user_data", &userData); err != nil {
    // Handle error
}
```

### 2. Key Naming

Use consistent, descriptive keys:

```go
const (
    KeyUserID     = "user_id"
    KeyAuthToken  = "auth_token"
    KeyResults    = "processing_results"
    KeyErrorCount = "error_count"
)
```

### 3. Data Structure

Store structured data for clarity:

```go
type WorkflowContext struct {
    RequestID string
    UserID    int
    StartTime time.Time
    Metadata  map[string]string
}

shared.Set("context", WorkflowContext{
    RequestID: "req-123",
    UserID:    456,
    StartTime: time.Now(),
    Metadata:  map[string]string{"source": "api"},
})
```

### 4. Cleanup

Clear sensitive data when done:

```go
defer func() {
    // Clear sensitive data
    shared.Set("auth_token", nil)
    shared.Set("api_key", nil)
}()
```

### 5. Documentation

Document expected keys:

```go
// SharedStore keys used by this flow:
// - "input_file": string - Path to input file
// - "output_dir": string - Output directory path
// - "processed_count": int - Number of processed items
// - "errors": []error - Collection of errors
```

## Debugging

Use GetAll for debugging:

```go
func debugSharedStore(shared *flyt.SharedStore) {
    data := shared.GetAll()
    fmt.Println("=== SharedStore Contents ===")
    for k, v := range data {
        fmt.Printf("%s: %T = %v\n", k, v, v)
    }
    fmt.Println("===========================")
}
```

## Next Steps

- [Nodes](/concepts/nodes) - Use SharedStore in node lifecycle
- [Batch Processing](/advanced/batch-processing) - SharedStore in batch operations
- [Best Practices](/best-practices) - General Flyt best practices