# Nodes

Nodes are the fundamental building blocks of Flyt workflows. Each node represents a single unit of work with a well-defined lifecycle.

## Node Lifecycle

Every node has three phases that execute in order:

### 1. Prep Phase

The preparation phase reads from the SharedStore and prepares data for execution.

```go
func (n *MyNode) Prep(ctx context.Context, shared *flyt.SharedStore) (any, error) {
    // Read data using type-safe getters
    userID := shared.GetInt("user_id")
    apiKey := shared.GetString("api_key")
    
    // Or bind complex types
    var config Config
    if err := shared.Bind("config", &config); err != nil {
        return nil, err
    }
    
    // Prepare and return data for Exec phase
    return map[string]any{
        "userID": userID,
        "apiKey": apiKey,
        "config": config,
    }, nil
}
```

### 2. Exec Phase

The execution phase performs the main work. This phase can be retried on failure.

```go
func (n *MyNode) Exec(ctx context.Context, prepResult any) (any, error) {
    data := prepResult.(map[string]any)
    
    // Perform the main operation
    result, err := processData(data["input"])
    if err != nil {
        return nil, err // Will trigger retry if configured
    }
    
    return result, nil
}
```

### 3. Post Phase

The post-processing phase handles results and determines the next action.

```go
func (n *MyNode) Post(ctx context.Context, shared *flyt.SharedStore, prepResult, execResult any) (flyt.Action, error) {
    // Store results
    shared.Set("output", execResult)
    
    // Determine next action based on results
    if isValid(execResult) {
        return "success", nil
    }
    return "failure", nil
}
```

## Creating Nodes

### Using Helper Functions

Flyt provides two styles of helper functions for creating nodes:

#### Result-based Functions (Type-Safe)

Use `WithPrepFunc`, `WithExecFunc`, and `WithPostFunc` for type-safe operations with the Result type:

```go
node := flyt.NewNode(
    flyt.WithPrepFuncAny(func(ctx context.Context, shared *flyt.SharedStore) (flyt.Result, error) {
        // Use type-safe getters
        message := shared.GetString("message")
        retryCount := shared.GetIntOr("retry_count", 0)
        
        return flyt.NewResult(map[string]any{
            "message": message,
            "retry": retryCount,
        }), nil
    }),
    flyt.WithExecFuncAny(func(ctx context.Context, prepResult flyt.Result) (flyt.Result, error) {
        // Type-safe access to data
        data := prepResult.AsMapOr(nil)
        message := data["message"].(string)
        
        // Process and return Result
        processed := processMessage(message)
        return flyt.NewResult(processed), nil
    }),
    flyt.WithPostFuncAny(func(ctx context.Context, shared *flyt.SharedStore, prepResult, execResult flyt.Result) (flyt.Action, error) {
        // Type-safe result handling
        result := execResult.Value()
        shared.Set("result", result)
        
        if shared.GetInt("retry_count") > 3 {
            return "max_retries", nil
        }
        return flyt.DefaultAction, nil
    }),
)
```

#### Any-based Functions (Simple)

Use `WithPrepFuncAny`, `WithExecFuncAny`, and `WithPostFuncAny` for simpler cases or backward compatibility:

```go
node := flyt.NewNode(
    flyt.WithPrepFuncAny(func(ctx context.Context, shared *flyt.SharedStore) (any, error) {
        // Direct any types
        message := shared.GetString("message")
        retryCount := shared.GetIntOr("retry_count", 0)
        
        return map[string]any{
            "message": message,
            "retry": retryCount,
        }, nil
    }),
    flyt.WithExecFuncAny(func(ctx context.Context, prepResult any) (any, error) {
        data := prepResult.(map[string]any)
        // Process the data
        return processMessage(data["message"].(string)), nil
    }),
    flyt.WithPostFuncAny(func(ctx context.Context, shared *flyt.SharedStore, prepResult, execResult any) (flyt.Action, error) {
        // Store result and determine action
        shared.Set("result", execResult)
        
        if shared.GetInt("retry_count") > 3 {
            return "max_retries", nil
        }
        return flyt.DefaultAction, nil
    }),
)
```

### Choosing Between Result and Any

**Use Result-based functions when:**
- You need type-safe access to data with convenience methods
- Working with complex data transformations
- You want better IDE support and type checking
- Building reusable components that handle various data types

**Use Any-based functions when:**
- Building simple nodes with straightforward logic
- Migrating existing code that uses `any` types
- The overhead of Result wrapping isn't justified
- Working with known, simple data types

### Custom Node Types

For complex nodes with state:

```go
type DatabaseNode struct {
    *flyt.BaseNode
    db *sql.DB
}

func NewDatabaseNode(db *sql.DB) *DatabaseNode {
    return &DatabaseNode{
        BaseNode: flyt.NewBaseNode(),
        db: db,
    }
}

func (n *DatabaseNode) Exec(ctx context.Context, prepResult any) (any, error) {
    query := prepResult.(string)
    rows, err := n.db.QueryContext(ctx, query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    // Process rows...
    return results, nil
}
```

## Node Options

Configure node behavior with options:

```go
// With Result type
node := flyt.NewNode(
    flyt.WithExecFuncAny(func(ctx context.Context, input flyt.Result) (flyt.Result, error) {
        // Type-safe operations
        return flyt.NewResult(processData(input.Value())), nil
    }),
    flyt.WithMaxRetries(3),        // Retry up to 3 times
    flyt.WithWait(time.Second * 2), // Wait 2 seconds between retries
)

// With any type
node := flyt.NewNode(
    flyt.WithExecFuncAny(func(ctx context.Context, input any) (any, error) {
        // Direct any handling
        return processData(input), nil
    }),
    flyt.WithMaxRetries(3),        // Retry up to 3 times
    flyt.WithWait(time.Second * 2), // Wait 2 seconds between retries
)
```

## BaseNode

The `BaseNode` provides default implementations:

```go
type MyNode struct {
    *flyt.BaseNode
    // Add custom fields
}

func NewMyNode() *MyNode {
    return &MyNode{
        BaseNode: flyt.NewBaseNode(
            flyt.WithMaxRetries(5),
            flyt.WithWait(time.Second),
        ),
    }
}

// Override only the methods you need
func (n *MyNode) Exec(ctx context.Context, prepResult any) (any, error) {
    // Custom exec logic
    return result, nil
}
```

## Thread Safety

Nodes should be thread-safe if used in concurrent batch operations:

```go
type SafeNode struct {
    *flyt.BaseNode
    mu      sync.Mutex
    counter int
}

func (n *SafeNode) Exec(ctx context.Context, prepResult any) (any, error) {
    n.mu.Lock()
    n.counter++
    count := n.counter
    n.mu.Unlock()
    
    return fmt.Sprintf("Execution #%d", count), nil
}
```

## Best Practices

1. **Single Responsibility**: Each node should do one thing well
2. **Idempotency**: Design nodes to be safely retryable
3. **Context Handling**: Always respect context cancellation
4. **Error Handling**: Return clear, actionable errors
5. **Resource Management**: Clean up resources in defer blocks

## Next Steps

- [Actions](/concepts/actions) - Control flow with actions
- [Flows](/concepts/flows) - Connect nodes into workflows
- [Custom Node Types](/advanced/custom-nodes) - Advanced node patterns