# Quick Start

This guide will help you build your first Flyt workflow in 5 minutes.

## Your First Node

Let's start with a simple node that processes data. You can choose between two approaches:

### Using Result Type (Recommended for Type Safety)

```go
package main

import (
    "context"
    "fmt"
    "github.com/mark3labs/flyt"
)

func main() {
    // Create a node with Result type using fluent API
    node := flyt.NewNode().
        WithExecFunc(func(ctx context.Context, prepResult flyt.Result) (flyt.Result, error) {
            fmt.Println("Processing data...")
            return flyt.NewResult("Hello, Flyt!"), nil
        })

    // Or using traditional style with options
    node = flyt.NewNode(
        flyt.WithExecFunc(func(ctx context.Context, prepResult flyt.Result) (flyt.Result, error) {
            fmt.Println("Processing data...")
            return flyt.NewResult("Hello, Flyt!"), nil
        }),
    )

    // Create shared store and context
    shared := flyt.NewSharedStore()
    ctx := context.Background()

    // Run the node
    action, err := flyt.Run(ctx, node, shared)
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Completed with action: %s\n", action)
}
```

### Using Any Type (Simple Approach)

```go
func main() {
    // Create a node with any type using fluent API
    node := flyt.NewNode().
        WithExecFuncAny(func(ctx context.Context, prepResult any) (any, error) {
            fmt.Println("Processing data...")
            return "Hello, Flyt!", nil
        })

    // Create shared store and context
    shared := flyt.NewSharedStore()
    ctx := context.Background()

    // Run the node
    action, err := flyt.Run(ctx, node, shared)
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Completed with action: %s\n", action)
}
```

## Building a Flow

Now let's create a simple workflow with multiple nodes:

```go
package main

import (
    "context"
    "fmt"
    "github.com/mark3labs/flyt"
)

func main() {
    // Create nodes using Result type for type safety
    fetchNode := flyt.NewNode(
        flyt.WithExecFunc(func(ctx context.Context, prepResult flyt.Result) (flyt.Result, error) {
            fmt.Println("Fetching data...")
            data := map[string]string{"data": "important info"}
            return flyt.NewResult(data), nil
        }),
        flyt.WithPostFunc(func(ctx context.Context, shared *flyt.SharedStore, prepResult, execResult flyt.Result) (flyt.Action, error) {
            shared.Set("fetched_data", execResult.Value())
            return flyt.DefaultAction, nil
        }),
    )

    processNode := flyt.NewNode(
        flyt.WithPrepFunc(func(ctx context.Context, shared *flyt.SharedStore) (flyt.Result, error) {
            // Use GetMap for type-safe access
            data := shared.GetMap("fetched_data")
            return flyt.NewResult(data), nil
        }),
        flyt.WithExecFunc(func(ctx context.Context, prepResult flyt.Result) (flyt.Result, error) {
            // Type-safe map access
            data := prepResult.AsMapOr(nil)
            fmt.Printf("Processing: %v\n", data["data"])
            result := "processed: " + fmt.Sprint(data["data"])
            return flyt.NewResult(result), nil
        }),
    )

    // Build the flow
    flow := flyt.NewFlow(fetchNode)
    flow.Connect(fetchNode, flyt.DefaultAction, processNode)

    // Run the flow
    shared := flyt.NewSharedStore()
    ctx := context.Background()
    
    err := flow.Run(ctx, shared)
    if err != nil {
        panic(err)
    }
    
    fmt.Println("Flow completed successfully!")
}
```

## Adding Error Handling

Let's add retry logic and error handling:

```go
func createRobustNode() flyt.Node {
    attempts := 0
    
    // Using fluent API for configuration
    return flyt.NewNode().
        WithExecFuncAny(func(ctx context.Context, prepResult any) (any, error) {
            attempts++
            fmt.Printf("Attempt %d...\n", attempts)
            
            // Simulate flaky operation
            if attempts < 2 {
                return nil, fmt.Errorf("temporary failure")
            }
            
            return "Success!", nil
        }).
        WithMaxRetries(3).
        WithWait(time.Second)
}
```

## Using Shared Store

The SharedStore allows nodes to communicate:

```go
func main() {
    shared := flyt.NewSharedStore()
    
    // Set initial data
    shared.Set("config", map[string]any{
        "timeout": 30,
        "retries": 3,
    })
    
    node := flyt.NewNode(
        flyt.WithPrepFuncAny(func(ctx context.Context, shared *flyt.SharedStore) (any, error) {
            config := shared.GetMap("config")
            return config, nil
        }),
        flyt.WithExecFuncAny(func(ctx context.Context, prepResult any) (any, error) {
            config := prepResult.(map[string]any)
            fmt.Printf("Using config: %v\n", config)
            return "configured", nil
        }),
    )
    
    ctx := context.Background()
    flyt.Run(ctx, node, shared)
}
```

## Next Steps

Now that you've built your first workflow, explore:

- [Nodes](/concepts/nodes) - Deep dive into node lifecycle
- [Actions](/concepts/actions) - Control flow with actions
- [Error Handling](/patterns/error-handling) - Build resilient workflows
- [Examples](https://github.com/mark3labs/flyt/tree/main/cookbook) - Real-world use cases