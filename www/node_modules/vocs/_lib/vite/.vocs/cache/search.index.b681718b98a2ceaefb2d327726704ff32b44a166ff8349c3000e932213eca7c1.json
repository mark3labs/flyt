"{\"value\":{\"mdx\":\"# Flows\\n\\nFlows connect nodes together to create workflows. They define the execution path based on actions returned by nodes.\\n\\n## Creating Flows\\n\\nStart with a single node and build connections:\\n\\n```go\\n// Create nodes\\nstartNode := createStartNode()\\nprocessNode := createProcessNode()\\nendNode := createEndNode()\\n\\n// Build flow\\nflow := flyt.NewFlow(startNode)\\nflow.Connect(startNode, flyt.DefaultAction, processNode)\\nflow.Connect(processNode, flyt.DefaultAction, endNode)\\n```\\n\\n## Running Flows\\n\\nExecute a flow with a context and SharedStore:\\n\\n```go\\nctx := context.Background()\\nshared := flyt.NewSharedStore()\\n\\n// Add initial data\\nshared.Set(\\\"input\\\", \\\"data to process\\\")\\n\\n// Run the flow\\nerr := flow.Run(ctx, shared)\\nif err != nil {\\n    log.Fatal(err)\\n}\\n\\n// Get results\\nresult, _ := shared.Get(\\\"output\\\")\\n```\\n\\n## Flow Connections\\n\\n### Linear Flow\\n\\nSimple sequential execution:\\n\\n```go\\nflow := flyt.NewFlow(node1)\\nflow.Connect(node1, flyt.DefaultAction, node2)\\nflow.Connect(node2, flyt.DefaultAction, node3)\\nflow.Connect(node3, flyt.DefaultAction, nil) // Terminate\\n```\\n\\n### Branching Flow\\n\\nMultiple paths based on actions:\\n\\n```go\\nflow := flyt.NewFlow(decisionNode)\\nflow.Connect(decisionNode, \\\"path_a\\\", nodeA)\\nflow.Connect(decisionNode, \\\"path_b\\\", nodeB)\\nflow.Connect(nodeA, flyt.DefaultAction, mergeNode)\\nflow.Connect(nodeB, flyt.DefaultAction, mergeNode)\\n```\\n\\n### Loop Flow\\n\\nCreate cycles for retry or iteration:\\n\\n```go\\nflow := flyt.NewFlow(startNode)\\nflow.Connect(startNode, flyt.DefaultAction, processNode)\\nflow.Connect(processNode, \\\"retry\\\", startNode)    // Loop back\\nflow.Connect(processNode, \\\"success\\\", endNode)\\n```\\n\\n## Flow as Node\\n\\nFlows implement the Node interface and can be used as nodes:\\n\\n```go\\n// Create a sub-flow\\nsubFlow := flyt.NewFlow(validateNode)\\nsubFlow.Connect(validateNode, flyt.DefaultAction, transformNode)\\n\\n// Use sub-flow in main flow\\nmainFlow := flyt.NewFlow(fetchNode)\\nmainFlow.Connect(fetchNode, flyt.DefaultAction, subFlow)\\nmainFlow.Connect(subFlow, flyt.DefaultAction, saveNode)\\n```\\n\\n## Complex Flow Patterns\\n\\n### Diamond Pattern\\n\\nSplit and merge execution paths:\\n\\n```go\\nflow := flyt.NewFlow(splitNode)\\nflow.Connect(splitNode, \\\"path1\\\", process1)\\nflow.Connect(splitNode, \\\"path2\\\", process2)\\nflow.Connect(process1, flyt.DefaultAction, mergeNode)\\nflow.Connect(process2, flyt.DefaultAction, mergeNode)\\n```\\n\\n### Error Handling Flow\\n\\nCentralized error handling:\\n\\n```go\\nflow := flyt.NewFlow(startNode)\\nflow.Connect(startNode, \\\"error\\\", errorHandler)\\nflow.Connect(startNode, flyt.DefaultAction, processNode)\\nflow.Connect(processNode, \\\"error\\\", errorHandler)\\nflow.Connect(processNode, flyt.DefaultAction, saveNode)\\nflow.Connect(saveNode, \\\"error\\\", errorHandler)\\n```\\n\\n### Pipeline Pattern\\n\\nData transformation pipeline:\\n\\n```go\\nflow := flyt.NewFlow(fetchNode)\\nflow.Connect(fetchNode, flyt.DefaultAction, validateNode)\\nflow.Connect(validateNode, \\\"valid\\\", transformNode)\\nflow.Connect(validateNode, \\\"invalid\\\", rejectNode)\\nflow.Connect(transformNode, flyt.DefaultAction, enrichNode)\\nflow.Connect(enrichNode, flyt.DefaultAction, saveNode)\\n```\\n\\n## Flow Composition\\n\\nBuild complex flows from simpler ones:\\n\\n```go\\nfunc createValidationFlow() *flyt.Flow {\\n    checkFormat := createFormatChecker()\\n    checkBusiness := createBusinessRules()\\n    \\n    flow := flyt.NewFlow(checkFormat)\\n    flow.Connect(checkFormat, \\\"valid\\\", checkBusiness)\\n    return flow\\n}\\n\\nfunc createMainFlow() *flyt.Flow {\\n    fetch := createFetchNode()\\n    validation := createValidationFlow()\\n    process := createProcessNode()\\n    \\n    flow := flyt.NewFlow(fetch)\\n    flow.Connect(fetch, flyt.DefaultAction, validation)\\n    flow.Connect(validation, flyt.DefaultAction, process)\\n    return flow\\n}\\n```\\n\\n## Debugging Flows\\n\\nAdd logging nodes for debugging:\\n\\n```go\\nfunc createLoggingNode(name string) flyt.Node {\\n    return flyt.NewNode(\\n        flyt.WithPrepFunc(func(ctx context.Context, shared *flyt.SharedStore) (any, error) {\\n            log.Printf(\\\"[%s] Prep: SharedStore keys: %v\\\", name, shared.GetAll())\\n            return nil, nil\\n        }),\\n        flyt.WithExecFunc(func(ctx context.Context, prepResult any) (any, error) {\\n            log.Printf(\\\"[%s] Exec\\\", name)\\n            return prepResult, nil\\n        }),\\n        flyt.WithPostFunc(func(ctx context.Context, shared *flyt.SharedStore, prepResult, execResult any) (flyt.Action, error) {\\n            log.Printf(\\\"[%s] Post: Result: %v\\\", name, execResult)\\n            return flyt.DefaultAction, nil\\n        }),\\n    )\\n}\\n\\n// Insert between nodes for debugging\\nflow.Connect(node1, flyt.DefaultAction, createLoggingNode(\\\"debug\\\"))\\nflow.Connect(createLoggingNode(\\\"debug\\\"), flyt.DefaultAction, node2)\\n```\\n\\n## Best Practices\\n\\n1. **Start Simple**: Build flows incrementally, testing as you go\\n2. **Name Nodes**: Give nodes descriptive names for easier debugging\\n3. **Document Flows**: Create diagrams or comments explaining flow logic\\n4. **Reuse Flows**: Extract common patterns into reusable sub-flows\\n5. **Test Flows**: Write tests for different execution paths\\n\\n## Visualizing Flows\\n\\nDocument your flows with diagrams:\\n\\n```mermaid\\ngraph TD\\n    Start([Start])\\n    Validate[Validate]\\n    Process[Process]\\n    Save[Save]\\n    Error[Error]\\n    \\n    Start -->|default| Validate\\n    Validate -->|valid| Process\\n    Validate -->|invalid| Error\\n    Process -->|default| Save\\n```\\n\\n## Next Steps\\n\\n- [Shared Store](/concepts/shared-store) - Share data between nodes\\n- [Nested Flows](/advanced/nested-flows) - Advanced composition\\n- [Batch Flows](/advanced/batch-flows) - Process multiple inputs\",\"document\":[]}}"
